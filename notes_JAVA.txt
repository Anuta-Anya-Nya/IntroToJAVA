КОНСПЕКТ java
API - сторонний сервис для работы с чем-то (ТГ бот, яндекс карты, ВК, погода)

Снипеты:
cl квадратик class
ma квадратик main - точка входа
sysout

Запуск java название.java
/*
комментарий
*/
//комментарий
----------------------------------
ТИПЫ ДАННЫХ И ПЕРЕМЕНЫХ
1. Ссылочные - классы и интерфейсы
                массивы
2. Примитивы -  boolean
                int, short, long и тд
                float, double
                char
float e = 2.7f; // суффикс f обязателен
double p = 5.66666;
-----------------------------------
int[] arr = new int[10];
arr = new int[] {1, 2, 3, 4}
arr.
int[] arr[] = new int[3][4] многомерный массив
int[][] arr= new int[3][4]
-----------------------------------
Получение ввода
import java.util.Scanner
в точке входа в программу:
    Scanner iScanner = new Scanner(System.in);
    System.out.printf("name: ");
    String name = iScanner.nextLine(); или nextInt() hasNextInt возвращает флаг цифра или нет
    System.out.printf("Привет, %s!\n", name);
    iScanner.close();
--------------------------------------
String res = String.format("%d + %d = %d /n", a, b, c)
System.out.printf("%d + %d = %d /n", a, b, c);
Маски спецификаторы
%d - целочисленные значения
%f - Числа с плавающей точкой, %.2f - с 2 символами после запятой
%c - вывод одиночного чара
%s - вывод строки
----------------------------------------
СТРОКИ
StringBuilder str = new StringBuilder(); оптимизирован под работу со строками
    str.append(word); добавляет слово в конец
    String result = str.toString(); конвертируем в строку


----------------------------------------
String timeStr = String.valueOf(nowTime); конверт в стринг
int num = Integer.valueOf(number);
------------------------------
Запись файлов
FileWriter writer = new FileWriter(fileName, true) второй параметр - записывать или нет
writer.write(str); запись строки
writer.append('E'); запись по символам
writer.flush();    передает в файл все из буфера

try(FileWriter writer = new FileWriter("notes3.txt", false))
        {что делаем если такой файл найден}
catch(IOException ex){
            System.out.println(ex.getMessage()); запись ошибки передает в консоль
        } 
File f1=new File(path); обьект для работы с файлами

<>; дженерик
ArrayList<Integer> arr=new ArrayList<>(Arrays.asList(4,5,16,45,33,45,22)); сразу заполяем 
array - элементы в памяти занимает место друг за другом. для добавления\удаления все после элементы сдвигаются, выделяется память для нового массива и заменяется ссылка из переменной. долго вставлять\удалять. быстро считывать
LinkedList - односвязный список - элементы стоят в разных местах, имеют ссылку на следующий элемент. при добавлении\удалении элемента просто перекидывается ссылка. добго считывать, быстро добавлять\удалять элемент
            циклический односвязный список - последний элемент знает о следующем и это первый элемент
            двусвязный список - элемент имеет ссылку на следующий  предыдущий элемент. 
            двунаправленный циклический список - двусвязный список, последний элемент знает о следующем (это первый), а первый знает о предыдущем(и это последний)
LinkedList<Integer> ll=new LinkedList<Integer>();

Queue - кто первый пришел, то  и первый отработан(FiFo - first in, first out) однонаправленный список
Queue<Integer> ll=new LinkedList<Integer>();
PriorityQueue - наивысший приоритет имеет "наименьший" элемент
PriorityQueue<Integer> ll=new PriorityQueue<Integer>(); при обавлении или удалении обрабатываются меньшие элементы
Deque - линейная коллекция которая поддержавает вставку и удаление элементов на обоих концах. двунаправленная очередь
Deque<Integer> dq= new ArrayDeque<>();
Stack - данные которые пришли в конце, отрабатывают в начале. first in, last out

Map множество коллекций,  работаюзих с данными ключ/значение (как словарь(ключ\значение)
порядок добавления не запоминается, ускоренная обработка ДАННЫХ
в качестве ключа может выступать null(пустая ссылка)
Map<Integer, String> m = new HashMap<>();
  m.put(2, "два") добавление пары. если есть такой ключ, перезапись
  m.putIfAbsent() добавление если ключ не найден
TreeMap - быстрее получает достп к элемнтам, хранятся в виде дерева
LinkedhashMap - помнит порядок добавления элеентов, более медлительный
HashTable - устаревшая, не знает про null 

Set - на основе мэп, только содержит уникальный ключ. значение заполнено не  варжной константой 
Set<Integer> set = new HashSet<>()
     иногда может включать в ключ null
Set<Integer> set = new HashSet<>(Arrays.AsList{1,2,3,4,5,6})
TreeSet - множество упорядочено, null быть не может, 
LinkedHashSet - помнит поряок добавления
----------------------------------------------- 
ООП - 
использование классов и экземпляров этих классов
Создание собственных типов
стихийннй подход
процедурный подход - общие алгоритмы запаковываются в общую функцию
обьектно-ориентированный подход - функции и данные упаковывают и называют классом

формируем сущность - это класс (в джаве), структурные записи, записи и т.д.(шарп)
проектирование - как описать сущность
класс - задается общая структура, на основе которой создаются экземпляры
экземпляр класса - представители класса - определяются общам шаблоном(классом)- обьединение данных с одной стороны и методов для обработки этих данных с другой стороны
поля класса - данные, относящиеся к классу
методы класса - код для обработки полей класса










https://academy.yandex.ru/journal/osnovnye-vidy-sortirovok-i-primery-ikh-realizatsii Виды сортировок
STONE17th
